using System;
using System.Collections.Generic;
using UnityEngine;

namespace TDMHP.Combat.Damage
{
    /// <summary>
    /// Exact invulnerability windows defined in absolute unscaled time.
    /// Supports scheduling windows in the future (e.g., i-frames that start later).
    /// </summary>
    public sealed class Invulnerability : MonoBehaviour
    {
        private struct Window
        {
            public double start;
            public double end;

            public Window(double start, double end)
            {
                this.start = start;
                this.end = end;
            }
        }

        [SerializeField] private bool _debugLog;

        private readonly List<Window> _windows = new(4);

        public bool IsInvulnerable
        {
            get
            {
                double now = Time.unscaledTimeAsDouble;
                CleanupExpired(now);

                for (int i = 0; i < _windows.Count; i++)
                {
                    var w = _windows[i];
                    if (now >= w.start && now < w.end)
                        return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Add an invulnerability window using absolute unscaled timestamps.
        /// Example: start = Time.unscaledTimeAsDouble + 0.05, end = start + 0.15
        /// </summary>
        public void AddWindow(double startTime, double endTime)
        {
            if (endTime <= startTime) return;

            // Drop already-expired windows
            double now = Time.unscaledTimeAsDouble;
            if (endTime <= now) return;

            // Clamp start so we don't store "past" start times unnecessarily
            if (startTime < now) startTime = now;

            _windows.Add(new Window(startTime, endTime));
            MergeOverlaps();

            if (_debugLog)
                Debug.Log($"[Invuln] AddWindow start={startTime:F3} end={endTime:F3} (now={now:F3}) count={_windows.Count}", this);
        }

        /// <summary>
        /// Convenience: invulnerable starting now for duration seconds.
        /// </summary>
        public void SetInvulnerableForSeconds(float duration)
        {
            if (duration <= 0f) return;
            double now = Time.unscaledTimeAsDouble;
            AddWindow(now, now + duration);
        }

        public void ClearAll()
        {
            _windows.Clear();
        }

        private void CleanupExpired(double now)
        {
            // Remove any windows whose end <= now
            for (int i = _windows.Count - 1; i >= 0; i--)
            {
                if (_windows[i].end <= now)
                    _windows.RemoveAt(i);
            }
        }

        private void MergeOverlaps()
        {
            if (_windows.Count <= 1) return;

            // Sort by start ascending
            _windows.Sort((a, b) => a.start.CompareTo(b.start));

            int write = 0;
            Window current = _windows[0];

            for (int i = 1; i < _windows.Count; i++)
            {
                var next = _windows[i];

                // Overlap or touch -> merge
                if (next.start <= current.end)
                {
                    current.end = Math.Max(current.end, next.end);
                }
                else
                {
                    _windows[write] = current;
                    write++;
                    current = next;
                }
            }

            _windows[write] = current;
            write++;

            // Trim
            if (write < _windows.Count)
                _windows.RemoveRange(write, _windows.Count - write);
        }
    }
}
